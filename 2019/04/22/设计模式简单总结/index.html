<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          设计模式简单总结 - 书友的博客 | ShuYou Blog
        
    </title>

    <link rel="canonical" href="http://yoursite-url/2019/04/22/设计模式简单总结/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('wallhaven-746664.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header">
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#设计模式" title="设计模式">设计模式</a>
                            
                        </div>
                        <h1>设计模式简单总结</h1>
                        <h2 class="subheading">关于设计模式做的一些记录 便于自己以后查看</h2>
                        <span class="meta">
                            Posted by Shu You on
                            2019-04-22
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">ShuYou Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h5 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h5><blockquote>
<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素包括以下四个方面：<br>模式名称 (Pattern name) 、<br>问题 (Problem) 、<br>解决方案 (Solution)、<br>效果 (Consequences) </p>
</blockquote>
<h5 id="为什么使用设计模式"><a href="#为什么使用设计模式" class="headerlink" title="为什么使用设计模式"></a>为什么使用设计模式</h5><blockquote>
<p>面向对象设计原则和设计模式也是对系统进行合理重构的指南针，重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性</p>
</blockquote>
<h5 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h5><blockquote>
<p>单一职责：一个类只负责一个功能领域中的相应职责</p>
</blockquote>
<blockquote>
<p>开闭原则：软件实体应对扩展开放，而对修改关闭</p>
</blockquote>
<blockquote>
<p>里氏代换原则：所有引用基类对象的地方能够透明地使用其子类的对象</p>
</blockquote>
<blockquote>
<p>依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象</p>
</blockquote>
<blockquote>
<p>接口隔离原则：使用多个专门接口，而不使用单一的总接口</p>
</blockquote>
<blockquote>
<p>合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的</p>
</blockquote>
<blockquote>
<p>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用</p>
</blockquote>
<p>下面这个图可能解释地更加通俗一点：<br><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/94DE62875E8D45E58AECC4D66CE22A83/1009" alt="image"></p>
<h4 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h4><blockquote>
<p>根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：</p>
</blockquote>
<blockquote>
<p>创建型模式主要用于创建对象。</p>
</blockquote>
<blockquote>
<p>结构型模式主要用于处理类或对象的组合。</p>
</blockquote>
<blockquote>
<p>行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。</p>
</blockquote>
<blockquote>
<p>根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：</p>
</blockquote>
<blockquote>
<p>类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。 </p>
</blockquote>
<blockquote>
<p>对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。 </p>
</blockquote>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/BCC63C68B4D9446AB7BAA20BE65117A8/1034" alt="image"><br><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/53A33190184F45B4A3ED86BF60DDBDA3/1038" alt="image"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br>设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素包括模式名称、问题、解决方案和效果。<br>设计模式根据其目的可分为创建型，结构型和行为型三种；根据范围可分为类模式和对象模式两种。<br>设计模式是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将避免我们做一些重复性的工作，而且可以设计出高质量的软件系统。</p>
</blockquote>
<h2 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h2><blockquote>
<p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
</blockquote>
<blockquote>
<p>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 </p>
</blockquote>
<h5 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h5><blockquote>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 </p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/8B315DE462E04891BE320EA8DDB4C006/1059" alt="image"></p>
<blockquote>
<p>模式结构<br>简单工厂模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Factory：工厂角色</font><br><font color="#FF8C00">Product：抽象产品角色</font><br><font color="#FF8C00">ConcreteProduct：具体产品角色</font>


<blockquote>
<p>模式分析<br>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。<br>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何Java源代码。<br>==简单工厂模式最大的问题在于工厂类的职责相对过重==，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。<br>简单工厂模式的要点在于：==当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节==。  </p>
</blockquote>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><blockquote>
<p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/B104F35C2F3D49638439DA0CB16959AF/1065" alt="image"></p>
<blockquote>
<p>模式结构<br>工厂方法模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Product：抽象产品</font><br><font color="#FF8C00">ConcreteProduct：具体产品</font><br><font color="#FF8C00">Factory：抽象工厂</font><br><font color="#FF8C00">ConcreteFactory：具体工厂</font>

<blockquote>
<p>模式分析<br>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。==在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做==。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，==这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品==。<br>当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体产品对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，==很好地符合了“开闭原则”==。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。==工厂方法模式退化后可以演变成简单工厂模式==。</p>
</blockquote>
<p>JDBC中的工厂方法:<br><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/1E81ADBAAB044414BA73784FE00777E7/1077" alt="image"></p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><blockquote>
<p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/3E9B080B7A9C42DB81BE757A863FDE18/1084" alt="image"></p>
<blockquote>
<p>模式结构<br>抽象工厂模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">AbstractFactory：抽象工厂</font><br><font color="#FF8C00">ConcreteFactory：具体工厂</font><br><font color="#FF8C00">AbstractProduct：抽象产品</font><br><font color="#FF8C00">Product：具体产品</font>

<blockquote>
<p>抽象工厂模式的主要优点是==隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便==；主要缺点==在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性==。<br>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 </p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/723F1761EE7F46C083EB19D22F1AE7DB/1089" alt="image"></p>
<h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h5><blockquote>
<p>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/EAAC0154685E4169B9D6BFC92D5A5DC4/1097" alt="image"></p>
<blockquote>
<p>建造者模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Builder：抽象建造者</font><br><font color="#FF8C00">ConcreteBuilder：具体建造者</font><br><font color="#FF8C00">Director：指挥者</font><br><font color="#FF8C00">Product：产品角色</font>

<blockquote>
<p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面==它隔离了客户与生产过程==；另一方面==它负责控制产品的生成过程==。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 </p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/0752EAAA095645ABBD0988F910C56164/1104" alt="image"></p>
<blockquote>
<p>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。<br>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</p>
</blockquote>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><blockquote>
<p>原型模式(Prototype Pattern)：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。 </p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/5B6D56EF4A7F48FBADD41B6DDB8D0E32/1111" alt="image"></p>
<blockquote>
<p>原型模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Prototype：抽象原型类</font><br><font color="#FF8C00">ConcretePrototype：具体原型类</font><br><font color="#FF8C00">Client：客户类</font>

<blockquote>
<p>在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/AAA84C7424DC438EBAF98BA39AC0DC9E/1116" alt="image"></p>
<blockquote>
<p>在浅克隆中，当对象被复制时它所包含的成员对象却没有被复制；在深克隆中，除了对象本身被复制外，对象包含的引用也被复制，也就是其中的成员对象也将复制。在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆；如果需要实现深克隆，可以通过序列化等方式来实现。</p>
</blockquote>
<blockquote>
<p>原型模式最大的优点在于可以快速创建很多相同或相似的对象，简化对象的创建过程，还可以保存对象的一些中间状态；其缺点在于需要为每一个类配备一个克隆方法，因此对已有类进行改造比较麻烦，需要修改其源代码，并且在实现深克隆时需要编写较为复杂的代码。</p>
</blockquote>
<blockquote>
<p>原型模式适用情况包括：创建新对象成本较大，新的对象可以通过原型模式对已有对象进行复制来获得；系统要保存对象的状态，而对象的状态变化很小；需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>
</blockquote>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><blockquote>
<p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/98A6F18416774FBF85E538CBA90062EF/1124" alt="image"></p>
<p>饿汉式单例与懒汉式单例类比较</p>
<blockquote>
<p>饿汉式单例类在自己被加载时就将自己实例化。单从资源利用效率角度来讲，这个比懒汉式单例类稍差些。从速度和反应时间角度来讲，则比懒汉式单例类稍好些。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/B06179F9ABBD4ED282E0F1993D318941/1126" alt="image"></p>
<blockquote>
<p>懒汉式单例类在实例化时，必须处理好在多个线程同时首次引用此类时的访问限制问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过同步化机制进行控制。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/52DB2F9FD17D484EA5D9C7D639706844/1128" alt="image"></p>
<blockquote>
<p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</p>
</blockquote>
<blockquote>
<p>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</p>
</blockquote>
<blockquote>
<p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建<br>。<br>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</p>
</blockquote>
<blockquote>
<p>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</p>
</blockquote>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote>
<p>结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 </p>
</blockquote>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><blockquote>
<p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/16D47EF8A2954289A481E8B022930332/1142" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/580F970A88564B2BB8078D6F21CC41C4/1144" alt="image"></p>
<blockquote>
<p>适配器模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Target：目标抽象类</font><br><font color="#FF8C00">Adapter：适配器类</font><br><font color="#FF8C00">Adaptee：适配者类</font><br><font color="#FF8C00">Client：客户类</font>

<blockquote>
<p>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/5369BAD58085463E8A6F61A543625FBB/1150" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/60A8DA2918E24070AD5230DF2E061B3A/1152" alt="image"></p>
<blockquote>
<p>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
</blockquote>
<blockquote>
<p>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</p>
</blockquote>
<blockquote>
<p>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。 </p>
</blockquote>
<h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><blockquote>
<p>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/4AEEAD6011104F70B0C1E9A4AF56D72D/1162" alt="image"></p>
<blockquote>
<p>桥接模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Abstraction：抽象类</font><br><font color="#FF8C00">RefinedAbstraction：扩充抽象类</font><br><font color="#FF8C00">Implementor：实现类接口</font><br><font color="#FF8C00">ConcreteImplementor：具体实现类</font>

<blockquote>
<p>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/428BD1F1BC294CD7950547F7002172C1/1163" alt="image"></p>
<blockquote>
<p>桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/2cd461df3bb6900a30e0825ddc5d38dd/xmlnote/A0F3C7679D2346D690EFFCA1DB687AB3/1165" alt="image"></p>
<blockquote>
<p>在桥接模式中，抽象化(Abstraction)与实现化(Implementation)脱耦，它们可以沿着各自的维度独立变化。</p>
</blockquote>
<blockquote>
<p>桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。</p>
</blockquote>
<blockquote>
<p>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</p>
</blockquote>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><blockquote>
<p>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/EE6EA319D6CB4AE6A2AB641B09778DA8/1180" alt="image"></p>
<blockquote>
<p>组合模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Component: 抽象构件</font><br><font color="#FF8C00">Leaf: 叶子构件</font><br><font color="#FF8C00">Composite: 容器构件</font><br><font color="#FF8C00">Client: 客户类</font>


<blockquote>
<p>组合模式用于组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。组合模式又可以称为“整体-部分”模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/4B30AC80E9094E2691F3E4F9B6851209/1182" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/AB795E348AE54C25BEB7B6E21525DFAB/1184" alt="image"></p>
<blockquote>
<p>组合模式包含三个角色：抽象构件为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现；叶子构件在组合结构中表示叶子节点对象，叶子节点没有子节点；容器构件在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为。</p>
</blockquote>
<blockquote>
<p>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。</p>
</blockquote>
<blockquote>
<p>组合模式的主要优点在于可以方便地对层次结构进行控制，客户端调用简单，客户端可以一致的使用组合结构或其中单个对象，用户就不必关心自己处理的是单个对象还是整个组合结构，简化了客户端代码；其缺点在于使设计变得更加抽象，且增加新构件时可能会产生一些问题，而且很难对容器中的构件类型进行限制。</p>
</blockquote>
<blockquote>
<p>组合模式适用情况包括：需要表示一个对象整体或部分层次；让客户能够忽略不同对象层次的变化，客户端可以针对抽象构件编程，无须关心对象层次结构的细节；对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们。</p>
</blockquote>
<blockquote>
<p>组合模式根据抽象构件类的定义形式，又可以分为透明组合模式和安全组合模式。</p>
</blockquote>
<h5 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h5><blockquote>
<p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/4FF4B1BC7C4A4BED8131EF9651196385/1196" alt="image"></p>
<blockquote>
<p>装饰模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Component: 抽象构件</font><br><font color="#FF8C00">ConcreteComponent: 具体构件</font><br><font color="#FF8C00">Decorator: 抽象装饰类</font><br><font color="#FF8C00">ConcreteDecorator: 具体装饰类</font>

<blockquote>
<p>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/111314758247451D9FC8862FEC557DA5/1200" alt="image"></p>
<blockquote>
<p>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
</blockquote>
<blockquote>
<p>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</p>
</blockquote>
<h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><blockquote>
<p>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/1CBE50639AD64A59AEF3CCB6ED33C13F/1207" alt="image"></p>
<blockquote>
<p>外观模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Facade: 外观角色</font><br><font color="#FF8C00">SubSystem:子系统角色</font>

<blockquote>
<p>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/E9BD81CC5286455DA054FD087FD3A8FE/1211" alt="image"></p>
<blockquote>
<p>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/4A69DBA275074A8893642EFEA059D3C7/1213" alt="image"></p>
<blockquote>
<p>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</p>
</blockquote>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><blockquote>
<p>享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/A895B8163868427690933D984F6F73EF/1222" alt="image"></p>
<blockquote>
<p>享元模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Flyweight: 抽象享元类</font><br><font color="#FF8C00">ConcreteFlyweight: 具体享元类</font><br><font color="#FF8C00">UnsharedConcreteFlyweight: 非共享具体享元类</font><br><font color="#FF8C00">FlyweightFactory: 享元工厂类</font>

<blockquote>
<p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态。其中内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/A3E86785923A4A3CB8520C099F11B4BF/1224" alt="image"></p>
<blockquote>
<p>享元模式主要优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；其缺点是使得系统更加复杂，并且需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</p>
</blockquote>
<blockquote>
<p>享元模式适用情况包括：一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；多次重复使用享元对象。</p>
</blockquote>
<h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><blockquote>
<p>代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/31B729C46AC14FFEBC1AE3F83BFB3190/1232" alt="image"></p>
<blockquote>
<p>代理模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Flyweight: 抽象享元类</font><br><font color="#FF8C00">Subject: 抽象主题角色</font><br><font color="#FF8C00">Proxy: 代理主题角色</font><br><font color="#FF8C00">RealSubject: 真实主题角色</font>

<blockquote>
<p>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/EC1777B2AAE94EC1A2A9B24CCF56D50E/1234" alt="image"></p>
<blockquote>
<p>远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/6AF631BF165A4A1289C90075C314158D/1236" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/02E8766BB9504F218F724DD577A98117/1238" alt="image"></p>
<blockquote>
<p>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</p>
</blockquote>
<blockquote>
<p>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
</blockquote>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote>
<p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</p>
</blockquote>
<blockquote>
<p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</p>
</blockquote>
<blockquote>
<p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 </p>
</blockquote>
<blockquote>
<p>行为型模式分为类行为型模式和对象行为型模式两种：</p>
</blockquote>
<blockquote>
<p>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</p>
</blockquote>
<blockquote>
<p>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</p>
</blockquote>
<h5 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h5><blockquote>
<p>职责链模式(Chain of Responsibility Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。由于英文翻译的不同，职责链模式又称为责任链模式，它是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/2AB08A6C79F241E68205186E4F727BDD/1267" alt="image"></p>
<blockquote>
<p>职责链模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Handler: 抽象处理者</font><br><font color="#FF8C00">ConcreteHandler: 具体处理者</font><br><font color="#FF8C00">Client: 客户类</font>

<blockquote>
<p>在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/3790E7D1BB1C49C98AD583E955A260C8/1271" alt="image"></p>
<blockquote>
<p>职责链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</p>
</blockquote>
<blockquote>
<p>职责链模式适用情况包括：有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求。</p>
</blockquote>
<h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><blockquote>
<p>命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/574156BEF1DC4B898DAE6AFDC1255CE4/1279" alt="image"></p>
<blockquote>
<p>命令模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Command: 抽象命令类</font><br><font color="#FF8C00">ConcreteCommand: 具体命令类</font><br><font color="#FF8C00">Invoker: 调用者</font><br><font color="#FF8C00">Receiver: 接收者</font><br><font color="#FF8C00">Client:客户类</font>

<blockquote>
<p>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</p>
</blockquote>
<blockquote>
<p>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</p>
</blockquote>
<blockquote>
<p>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作；需要将一组操作组合在一起，即支持宏命令。</p>
</blockquote>
<h5 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h5><blockquote>
<p>解释器模式(Interpreter Pattern) ：定义语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”意思是使用规定格式和语法的代码，它是一种类行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/803EE52C43DB4912916FB4B25B5298C9/1288" alt="image"></p>
<blockquote>
<p>解释器模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">AbstractExpression: 抽象表达式</font><br><font color="#FF8C00">TerminalExpression: 终结符表达式</font><br><font color="#FF8C00">NonterminalExpression: 非终结符表达式</font><br><font color="#FF8C00">Context: 环境类</font><br><font color="#FF8C00">Client: 客户类</font>

<blockquote>
<p>对于一个简单的语言可以使用一些文法规则来进行定义，还可以通过抽象语法树的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例。</p>
</blockquote>
<blockquote>
<p>解释器模式的主要优点包括易于改变和扩展文法，易于实现文法并增加了新的解释表达式的方式；其主要缺点是对于复杂文法难以维护，执行效率较低且应用场景很有限。</p>
</blockquote>
<blockquote>
<p>解释器模式适用情况包括：可以将一个需要解释执行的语言中的句子表示为一个抽象语法树；一些重复出现的问题可以用一种简单的语言来进行表达；文法较为简单且效率不是关键问题。</p>
</blockquote>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><blockquote>
<p>迭代器模式(Iterator Pattern) ：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/F3758FE2066246F5A389F8CDDA2AFFEB/1299" alt="image"></p>
<blockquote>
<p>迭代器模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Iterator: 抽象迭代器</font><br><font color="#FF8C00">ConcreteIterator: 具体迭代器</font><br><font color="#FF8C00">Aggregate: 抽象聚合类</font><br><font color="#FF8C00">ConcreteAggregate: 具体聚合类</font>

<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/B5EC6C191C1B4A73875F28A86B0D7E74/1303" alt="image"></p>
<blockquote>
<p>迭代器模式的主要优点在于它支持以不同的方式遍历一个聚合对象，还简化了聚合类，而且在同一个聚合上可以有多个遍历；其缺点在于增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/EABB23F1B2954AD9860986C5C313B573/1305" alt="image"></p>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/0E39B13ABF0B4994AC0459B6DC616FC7/1307" alt="image"></p>
<blockquote>
<p>迭代器模式适用情况包括：访问一个聚合对象的内容而无须暴露它的内部表示；需要为聚合对象提供多种遍历方式；为遍历不同的聚合结构提供一个统一的接口。</p>
</blockquote>
<blockquote>
<p>在JDK类库中，Collection的iterator()方法返回一个Iterator类型的对象，而其子接口List的listIterator()方法返回一个ListIterator类型的对象，ListIterator是Iterator的子类。它们构成了Java语言对迭代器模式的支持，Java语言的Iterator接口就是迭代器模式的应用。</p>
</blockquote>
<h5 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h5><blockquote>
<p>中介者模式(Mediator Pattern)定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/76B293559EC943F3A04625D09F9E387F/1319" alt="image"></p>
<blockquote>
<p>中介者模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Mediator: 抽象中介者</font><br><font color="#FF8C00">ConcreteMediator: 具体中介者</font><br><font color="#FF8C00">Colleague: 抽象同事类</font><br><font color="#FF8C00">ConcreteColleague: 具体同事类</font>


<blockquote>
<p>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/4803A874B24544C2A7409BAE3D9D4FED/1321" alt="image"></p>
<blockquote>
<p>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</p>
</blockquote>
<blockquote>
<p>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
</blockquote>
<h5 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h5><blockquote>
<p>备忘录模式(Memento Pattern)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为Token。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/38E5D7E899854CF9870425FD872F3E21/1332" alt="image"></p>
<blockquote>
<p>备忘录模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Originator: 原发器</font><br><font color="#FF8C00">Memento: 备忘</font><br><font color="#FF8C00">Caretaker: 负责</font>

<blockquote>
<p>备忘录对象通常封装了原发器的部分或所有的状态信息，而且这些状态不能被其他对象访问，也就是说不能在该对象之外保存其状态，因为暴露其内部状态将违反封装的原则，可能有损系统的可靠性和可扩展性。</p>
</blockquote>
<blockquote>
<p>备忘录模式的主要优点在于它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，还简化了原发器对象，备忘录只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次撤消操作，可以通过在负责人中定义集合对象来存储多个备忘录；备忘录模式的主要缺点在于资源消耗过大，因为每一个历史状态的保存都需要一个备忘录对象。</p>
</blockquote>
<blockquote>
<p>备忘录模式适用情况包括：保存一个对象在某一个时刻的状态或部分状态，这样以后需要时它能够恢复到先前的状态；如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</p>
</blockquote>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><blockquote>
<p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/A4890436580F48C7804CFDE6310B290D/1342" alt="image"></p>
<blockquote>
<p>观察者模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Subject: 目标</font><br><font color="#FF8C00">ConcreteSubject: 具体目标</font><br><font color="#FF8C00">Observer: 观察者</font><br><font color="#FF8C00">ConcreteObserver: 具体观察者</font>

<blockquote>
<p>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/EC5FFCDBB037435A8FAC809F17E3381E/1347" alt="image"></p>
<blockquote>
<p>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</p>
</blockquote>
<blockquote>
<p>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</p>
</blockquote>
<h5 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h5><blockquote>
<p>状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/AC20E48480F14316B9C2D1C613F60BCB/1356" alt="image"></p>
<blockquote>
<p>状态模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Context: 环境类</font><br><font color="#FF8C00">State: 抽象状态类</font><br><font color="#FF8C00">ConcreteState: 具体状态类</font>

<blockquote>
<p>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</p>
</blockquote>
<blockquote>
<p>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</p>
</blockquote>
<h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><blockquote>
<p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/25553A5D05EC4971A4DD4D4DC847381C/1366" alt="image"></p>
<blockquote>
<p>策略模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Context: 环境类</font><br><font color="#FF8C00">Strategy: 抽象策略类</font><br><font color="#FF8C00">ConcreteStrategy: 具体策略类</font>

<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/3A54857E92EC4D2588B555481B7F10A4/1368" alt="image"></p>
<blockquote>
<p>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</p>
</blockquote>
<blockquote>
<p>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</p>
</blockquote>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><blockquote>
<p>模板方法模式(Template Method Pattern)：定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/99599AE5B1BA4D67A35B46629F1B76E9/1378" alt="image"></p>
<blockquote>
<p>模板方法模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">AbstractClass: 抽象类</font><br><font color="#FF8C00">ConcreteClass:  具体子类</font>

<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/3A7DBA4942A64770A3A71921060C18A6/1383" alt="image"></p>
<blockquote>
<p>模板方法模式的优点在于在子类定义详细的处理算法时不会改变算法的结构，实现了代码的复用，通过对子类的扩展可以增加新的行为，符合“开闭原则”；其缺点在于需要为每个不同的实现都定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</p>
</blockquote>
<blockquote>
<p>模板方法模式适用情况包括：一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法，而一些可以改变的细节由其子类来实现；通过模板方法模式还可以控制子类的扩展。</p>
</blockquote>
<h5 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h5><blockquote>
<p>访问者模式(Visitor Pattern)：表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/ED28DFF155B346CEA017E3C03BE348FE/1398" alt="image"></p>
<blockquote>
<p>访问者模式包含如下角色：</p>
</blockquote>
<font color="#FF8C00">Vistor: 抽象访问者</font><br><font color="#FF8C00">ConcreteVisitor: 具体访问者</font><br><font color="#FF8C00">Element: 抽象元素</font><br><font color="#FF8C00">ConcreteElement: 具体元素</font><br><font color="#FF8C00">ObjectStructure: 对象结构</font>

<blockquote>
<p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/5287dd13af98d2a5060432b4dc044136/xmlnote/E4962FD5465D436DB295E415B8E6354F/1396" alt="image"></p>
<blockquote>
<p>访问者模式的主要优点在于使得增加新的访问操作变得很容易，将有关元素对象的访问行为集中到一个访问者对象中，而不是分散到一个个的元素类中，还可以跨过类的等级结构访问属于不同的等级结构的元素类，让用户能够在不修改现有类层次结构的情况下，定义该类层次结构的操作；其主要缺点在于增加新的元素类很困难，而且在一定程度上破坏系统的封装性。</p>
</blockquote>
<blockquote>
<p>访问者模式适用情况包括：一个对象结构包含很多类型的对象，希望对这些对象实施一些依赖其具体类型的操作；需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类；对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</p>
</blockquote>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2019/03/16/记录第一次博客文章/" data-toggle="tooltip" data-placement="top" title="记录第一次博客文章">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#设计模式"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">设计模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#什么是设计模式"><span class="toc-nav-number">1.0.0.1.</span> <span class="toc-nav-text">什么是设计模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#为什么使用设计模式"><span class="toc-nav-number">1.0.0.2.</span> <span class="toc-nav-text">为什么使用设计模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#设计模式的七大原则"><span class="toc-nav-number">1.0.0.3.</span> <span class="toc-nav-text">设计模式的七大原则</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#设计模式的分类"><span class="toc-nav-number">1.0.1.</span> <span class="toc-nav-text">设计模式的分类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#分类："><span class="toc-nav-number">1.0.2.</span> <span class="toc-nav-text">分类：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#小结"><span class="toc-nav-number">1.0.3.</span> <span class="toc-nav-text">小结</span></a></li></ol><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#创建型模式："><span class="toc-nav-number">2.</span> <span class="toc-nav-text">创建型模式：</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#简单工厂模式："><span class="toc-nav-number">2.0.0.1.</span> <span class="toc-nav-text">简单工厂模式：</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#工厂方法模式"><span class="toc-nav-number">2.0.0.2.</span> <span class="toc-nav-text">工厂方法模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#抽象工厂模式"><span class="toc-nav-number">2.0.0.3.</span> <span class="toc-nav-text">抽象工厂模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#建造者模式"><span class="toc-nav-number">2.0.0.4.</span> <span class="toc-nav-text">建造者模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#原型模式"><span class="toc-nav-number">2.0.0.5.</span> <span class="toc-nav-text">原型模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#单例模式"><span class="toc-nav-number">2.0.0.6.</span> <span class="toc-nav-text">单例模式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#结构型模式"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">结构型模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#适配器模式"><span class="toc-nav-number">3.0.0.1.</span> <span class="toc-nav-text">适配器模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#桥接模式"><span class="toc-nav-number">3.0.0.2.</span> <span class="toc-nav-text">桥接模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#组合模式"><span class="toc-nav-number">3.0.0.3.</span> <span class="toc-nav-text">组合模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#装饰模式"><span class="toc-nav-number">3.0.0.4.</span> <span class="toc-nav-text">装饰模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#外观模式"><span class="toc-nav-number">3.0.0.5.</span> <span class="toc-nav-text">外观模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#享元模式"><span class="toc-nav-number">3.0.0.6.</span> <span class="toc-nav-text">享元模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#代理模式"><span class="toc-nav-number">3.0.0.7.</span> <span class="toc-nav-text">代理模式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#行为型模式"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">行为型模式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#职责链模式"><span class="toc-nav-number">4.0.0.1.</span> <span class="toc-nav-text">职责链模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#命令模式"><span class="toc-nav-number">4.0.0.2.</span> <span class="toc-nav-text">命令模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#解释器模式"><span class="toc-nav-number">4.0.0.3.</span> <span class="toc-nav-text">解释器模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#迭代器模式"><span class="toc-nav-number">4.0.0.4.</span> <span class="toc-nav-text">迭代器模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#中介者模式"><span class="toc-nav-number">4.0.0.5.</span> <span class="toc-nav-text">中介者模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#备忘录模式"><span class="toc-nav-number">4.0.0.6.</span> <span class="toc-nav-text">备忘录模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#观察者模式"><span class="toc-nav-number">4.0.0.7.</span> <span class="toc-nav-text">观察者模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#状态模式"><span class="toc-nav-number">4.0.0.8.</span> <span class="toc-nav-text">状态模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#策略模式"><span class="toc-nav-number">4.0.0.9.</span> <span class="toc-nav-text">策略模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#模板方法模式"><span class="toc-nav-number">4.0.0.10.</span> <span class="toc-nav-text">模板方法模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#访问者模式"><span class="toc-nav-number">4.0.0.11.</span> <span class="toc-nav-text">访问者模式</span></a></li></ol></li>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#设计模式" title="设计模式">设计模式</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/ZouShuYou">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank" href="https://github.com/ZouShuYou">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Shu You 2019 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a>                    
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://yoursite-url/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="http://yoursite-url/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
